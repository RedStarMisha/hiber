EntityManager(Session в hibernate) - интерфейс для связи с PersistanceContext. Через него проходят все операции с бд и транзации. Создается и работает в рамках транзакции
EntityManagerFactory(SessionFactory в hibernate) - фабрика для создания EntityManager. Связана с persistence unit. Создается при запуске приложения
PErsistanceContext - кэш первого уровня. создается при открытии транзакции. по завершению транзакции сохраняется и очищается

--Параметры сущности
JavaBEans - они же POJO, но должны иметь дефолтный контсруктор и геттеры и сеттеры начинающиеся с set и get. Поля должны быть приватные или protected
В Hibernate доступ можно получать как через поле, так и через геттеры\сеттеры. По дефолту через поле. Для зименения можно над полем или классом применить аннотацию @Access. Можно задавать параметры над методом(над геттером). К примеру параметры id (@Id @GeneratedValue) можно повесить над геттером. Это укажет что доступ будет через методы, а не через поле
Возвращать через геттер можно другой экземпляр того же класса что и поле. Но коллекции должны возвращать именно тот экземпляр. Данное правило применимо когда доступ к сущностям через геттеры и сеттеры.
В качестве коллекций JPA требует использовать интерфейсы (List, Set, Collection), а не реализацию
Хорошая практика через геттеры возвращать неизменяемые коллекции переупаковывая аттрибут модели(для ситуации когда доступ к аттрибутам через поля - по дефолту) и делать отдельный методы к примеру для добавления сущности в коллекцию (вспомогательные методы)

--Аннотации
@Entity указывает что класс со своими полями теперь сохраняемый
Делать сеттер для Id плохая практика т.к он не переопределяется(в hibernatedhjlt)
@GeneratedValue - аннотация указывающая как генерить ID. Sequence по идее быстрее. почитать сравнение
    SEQUENCE - запрос id в базе перед сохранением в базу. эффективно когда более 1.
@SequenceGenerator настраивает параметры генератора если выбрана стратегия Sequence. Имя стратегии по дефолту выбирается равной имени класса
@Immutable - аннотация Hibernate. Указывает что сущность неизменяемая(на уровне persistanse). в JPA такой нет

@Transient - указывает, что поле класса не будет хранимым и не будет записываться в
@Coulumn(nullable) указывает что поле класса может (или не может) иметь null значение. обычно нужно когда поле бд NOT_NULL.Если объект с null полем будет отправлен на сохранение, то будет брошена ошибка. Можно вместо применить @NotNull
@Formula - может выводить значение после преобразование какой-нибудь колонки (преобразованием в sql). к примеру можно применить среднее значение, абсолютное значение или сабстринг для текста
@ColumnTransformer - необходимо для преобразования значения (напрbимер для перевода веса или расстояния в систему СИ и т.д)

@Generated указывает что значение будет сгенерировано БД. Можно указать что будет генериться как при вставке, там и при обновлении (ключ event). Удобно к примеру для поля "последнее обновление"
@ColumnDefault указывает значение колонки по умолчанию. Используется при автоматический генерации схемы. Может использоваться в сочетании с @Generated и @DynamicInsert. Если значение @Generated не используется, defaultоно может привести к потере синхронизации состояния, хранящегося в памяти, с базой данных.
@PrePersist вешается над методом в котором можно описать какие значения присвоить если к примеру поля null. метод позволяет нам программно устанавливать значения по умолчанию до того, как сущность будет сохранена. Это может быть полезно, если мы хотим гарантировать, что значения по умолчанию будут установлены, даже если сущность не инициализирована должным образом или если некоторые поля имеют значение null.
@PreUpdate тоже самое что @PrePersist только про update
@CreationTimestamp для генерации временной метки в момент создания (hibernate). Поддерживает генерацию на уровне VM и DB (параметр аннотации). Не работает в @Embeddable
@UpdateTimestamp для генерации временной метки в момент обновления (hibernate). Поддерживает генерацию на уровне VM и DB (параметр аннотации). Не работает в @Embeddable

@Temporal - применяется над полем имеющем тип время (в ситуации когда нет конвертера). Если аннотации нет, то в базу по умолчанию пишется TemporalType.TimeStamp
@Enumerated вешается на enum. Рекомендуется указывать EnumType.String чтобы в случае изменения порядка enum не было косяков

@Embeddable вешается на встроенный класс (@Embeded на поле в родительском. Нужно что-то одно). По факту просто представление в java. Просто оборачивает колонки главной таблицы в отдельную сущность. Доступ к полям такой же как у родительской сущности. Если встроенный класс равен null и родительский сохранить, то в его поля тоже запишутся null. и есть поля равны null, то когда из БД запрашивают родительскую сущность, то встроенный класс будет null.
@AttributeOverride - Если в рамках одного родительского класса используются 2 встроенных одинаковых класса, то будет конфликт по именам полей. Их можно исправить применив аннотацию @AttributeOverride над полем встроенного класса в родительский
@AttributeOverrides - если нужно переименовать несколько имен полей класса. В скобках перечисляются уже аннотации @AttributeOverride с подробным описанием

@Converter - аннотация указывающая что текущий класс конвертер. Необходимо имплементить интерфейс AttribureConverter. Помогает конвертировать на лету формат записи в колонке БД в сущность java. параметр autoApply = true указывает что конвертер применяется всегда когда используется сущность (иначе при применении текущей сущности над ней надо вешать аннотацию @Convert)

@ElementCollection - используется для добавления коллекции объектов примитивного типа или вложенного (embedable). позволяет неописывать сущность. Для ее хранения используется составной ключ из id главной сущности и значения хранимого в коллекции
@CollectionTable - указывает информацию о таблице коллекции. joinColumns = @JoinColumn - указывает что добавить колонку с родительской сущности
    под определенным именем
@OrderColumn - если коллекция - лист, то позволяет хранить порядок элементов по id. Создается отдельная колонка с порядком (order).
    но есть "НО" - к примеру при удалении сущности update индексов остальных будет проходить по одной. Нативный SQL запрос может сделать
    это в 1, что является предпочтительнее
@OrderBy - может сортировать при выполнении и извлечении (в отличие от варианта выше)
    не поддерживает вложенность в той сущности по которой сортируем (к примеру если List<Item>, а в Item есть Price с полями currency и price то мы не может указать через price.price)
    по дефолту ASC. Если не указываем поле по которому сортируем то по дефолту это ID.
    вот пример не стандартной сортировки @OrderBy("id DESC")
@MapKeyColumn - позволяет указать параметры ключа если мы храним коллекцию в Map. Значение также указывается в @Column
    если ключ Enum используем @MapKeyEnumerated. Если используем в качествеключа Embedabble класс то эти аннотации не нужны
@SortComparator - позволяет сортировать наши коллекции. Сортировка на уровне java кода
@JoinColumn отмечает столбец как столбец соединения для ассоциации сущностей. Не обязательная аннотация т.к аннотации связи
    сами помечают столбец и назначают ему дефолтное имя "имясущности_id"
@OneToMany - аннотация связи. mappedBy - обязательно при двунаправленной связи. Указывает что коллекцию надо загружать
    обратившись к сущности обратной стороны и стягивая по id главной сущности