EntityManager(Session в hibernate) - интерфейс для управления жизненным циклом сущностей.
    Имеет свой Persistent Context(создается при создании EntityManager). Через него проходят все операции с бд и транзации.
    Создается и работает в рамках транзакции
EntityManagerFactory(SessionFactory в hibernate) - фабрика для создания EntityManager. Связана с persistence unit.
    Создается при запуске приложения, сингальтон
PErsistanceContext - кэш первого уровня. создается при создании EntityManager. по завершению транзакции сохраняется и очищается

--Параметры сущности
JavaBEans - они же POJO, но должны иметь дефолтный контсруктор и геттеры и сеттеры начинающиеся с set и get. Поля должны быть приватные или protected
В Hibernate доступ можно получать как через поле, так и через геттеры\сеттеры. По дефолту через поле. Для зименения можно над полем или классом применить аннотацию @Access. Можно задавать параметры над методом(над геттером). К примеру параметры id (@Id @GeneratedValue) можно повесить над геттером. Это укажет что доступ будет через методы, а не через поле
Возвращать через геттер можно другой экземпляр того же класса что и поле. Но коллекции должны возвращать именно тот экземпляр. Данное правило применимо когда доступ к сущностям через геттеры и сеттеры.
В качестве коллекций JPA требует использовать интерфейсы (List, Set, Collection), а не реализацию
Хорошая практика через геттеры возвращать неизменяемые коллекции переупаковывая аттрибут модели(для ситуации когда доступ к аттрибутам через поля - по дефолту) и делать отдельный методы к примеру для добавления сущности в коллекцию (вспомогательные методы)

--Аннотации
@Entity указывает что класс со своими полями теперь сохраняемый
Делать сеттер для Id плохая практика т.к он не переопределяется(в hibernatedhjlt)
@GeneratedValue - аннотация указывающая как генерить ID. Sequence по идее быстрее. почитать сравнение
    SEQUENCE - запрос id в базе перед сохранением в базу. эффективно когда более 1.
@SequenceGenerator настраивает параметры генератора если выбрана стратегия Sequence. Имя стратегии по дефолту выбирается равной имени класса
@Immutable - аннотация Hibernate. Указывает что сущность неизменяемая(на уровне persistanse). в JPA такой нет. Данная аннотация
    помогает применять оптимизации

@Transient - указывает, что поле класса не будет хранимым и не будет записываться в
@Column(nullable) указывает что поле класса может (или не может) иметь null значение. обычно нужно когда поле бд NOT_NULL.Если объект с null полем будет отправлен на сохранение, то будет брошена ошибка. Можно вместо применить @NotNull
@Formula - может выводить значение после преобразование какой-нибудь колонки (преобразованием в sql). к примеру можно применить среднее значение, абсолютное значение или сабстринг для текста
@ColumnTransformer - необходимо для преобразования значения (напрbимер для перевода веса или расстояния в систему СИ и т.д)

@Generated указывает что значение будет сгенерировано БД. Можно указать что будет генериться как при вставке, там и при обновлении (ключ event). Удобно к примеру для поля "последнее обновление"
@ColumnDefault указывает значение колонки по умолчанию. Используется при автоматический генерации схемы. Может использоваться в сочетании с @Generated и @DynamicInsert. Если значение @Generated не используется, defaultоно может привести к потере синхронизации состояния, хранящегося в памяти, с базой данных.
@PrePersist вешается над методом в котором можно описать какие значения присвоить если к примеру поля null. метод позволяет нам программно устанавливать значения по умолчанию до того, как сущность будет сохранена. Это может быть полезно, если мы хотим гарантировать, что значения по умолчанию будут установлены, даже если сущность не инициализирована должным образом или если некоторые поля имеют значение null.
@PreUpdate тоже самое что @PrePersist только про update
@CreationTimestamp для генерации временной метки в момент создания (hibernate). Поддерживает генерацию на уровне VM и DB (параметр аннотации). Не работает в @Embeddable
@UpdateTimestamp для генерации временной метки в момент обновления (hibernate). Поддерживает генерацию на уровне VM и DB (параметр аннотации). Не работает в @Embeddable

@Temporal - применяется над полем имеющем тип время (в ситуации когда нет конвертера). Если аннотации нет, то в базу по умолчанию пишется TemporalType.TimeStamp
@Enumerated вешается на enum. Рекомендуется указывать EnumType.String чтобы в случае изменения порядка enum не было косяков

@Embeddable вешается на встроенный класс (@Embeded на поле в родительском. Нужно что-то одно). По факту просто представление в java. Просто оборачивает колонки главной таблицы в отдельную сущность. Доступ к полям такой же как у родительской сущности. Если встроенный класс равен null и родительский сохранить, то в его поля тоже запишутся null. и есть поля равны null, то когда из БД запрашивают родительскую сущность, то встроенный класс будет null.
@AttributeOverride - Если в рамках одного родительского класса используются 2 встроенных одинаковых класса, то будет конфликт по именам полей. Их можно исправить применив аннотацию @AttributeOverride над полем встроенного класса в родительский
@AttributeOverrides - если нужно переименовать несколько имен полей класса. В скобках перечисляются уже аннотации @AttributeOverride с подробным описанием

@Converter - аннотация указывающая что текущий класс конвертер. Необходимо имплементить интерфейс AttribureConverter. Помогает конвертировать на лету формат записи в колонке БД в сущность java. параметр autoApply = true указывает что конвертер применяется всегда когда используется сущность (иначе при применении текущей сущности над ней надо вешать аннотацию @Convert)

@ElementCollection - используется для добавления коллекции объектов примитивного типа или вложенного (embedable). позволяет неописывать сущность. Для ее хранения используется составной ключ из id главной сущности и значения хранимого в коллекции
@CollectionTable - указывает информацию о таблице коллекции. joinColumns = @JoinColumn - указывает что добавить колонку с родительской сущности
    под определенным именем
@OrderColumn - если коллекция - лист, то позволяет хранить порядок элементов по id. Создается отдельная колонка с порядком (order).
    но есть "НО" - к примеру при удалении сущности update индексов остальных будет проходить по одной. Нативный SQL запрос может сделать
    это в 1, что является предпочтительнее
@OrderBy - может сортировать при выполнении и извлечении (в отличие от варианта выше)
    не поддерживает вложенность в той сущности по которой сортируем (к примеру если List<Item>, а в Item есть Price с полями currency и price то мы не может указать через price.price)
    по дефолту ASC. Если не указываем поле по которому сортируем то по дефолту это ID.
    вот пример не стандартной сортировки @OrderBy("id DESC")
@MapKey - для связи один ко многим. Как обычно описываем OneToMany + в name указываем имя поля с id сущности
@MapKeyColumn - позволяет указать параметры ключа если мы храним коллекцию в Map. Значение также указывается в @Column
    если ключ Enum используем @MapKeyEnumerated. Если используем в качествеключа Embedabble класс то эти аннотации не нужны
@SortComparator - позволяет сортировать наши коллекции. Сортировка на уровне java кода



Связи в БД

@JoinColumn отмечает столбец как столбец соединения для ассоциации сущностей. Не обязательная аннотация т.к аннотации связи
    сами помечают столбец и назначают ему дефолтное имя "имясущности_id"
@OneToMany - аннотация связи. mappedBy - обязательно при двунаправленной связи. Указывает что коллекцию надо загружать
    обратившись к сущности обратной стороны и стягивая по id главной сущности
CASCADE - не стоит использовать каскад для связи ManyToOne. Это не логично, лучше использовать у обратной стороны
    Несколько типов каскада можно описывать в списке
@JoinTable - аннотация отвечающая за настройку таблицы связи. используется для связей @ManyToOne/@OneToMany.
    Не является обязательной. Только для таблицы хранящей идентификаторы (если будут еще поля, следует создавать отдельную сущность)
    Указывается на стороне владельца связи с промежуточной таблицей (т.е где нет mappedBy). Данный вариант рекомендуется
    использовать только в случаях отсутствия потенциального расширешния таблицы связи. Лучше использовать доп сущность
@ManyToMany с доп сущностью - создание доп сущности связи. При этом @ManyToMany в базовых сущностях
    меняется на @OneToMany. А на сторони сущности связи будет @ManyToOne(+ @JoinColumn). У сущности связи будет составной ID
@EmbeddedId - Аннотация для работы с составными (композитными) ключами. Вешается над полем которое является составным ID. При этом
    создается класс для id (аннотация над классом @Embedable) который должен быть implements Serializable и в качестве полей
     указываем наши id (не забывая про @Column). Имя колонки в @Column и в @JoinColumn (из сущности связи над ссылкой на сущность)
     должны совпадать.
     Если случай, когда часть составного ключа id сущности на которою есть ссылка в самом классе, то на ссылку на сущность
        вешается аннотация @MapsId("") с указанием имени поля в составном id

Persistent Life Cycle
JPA определяет 4 состояния: Transient(временное), Persistent, Removed, Detached
Transient - состояние объектов которые созданы через new но по сути еще не находятся в БД (не был вызнан метод persist)
Persistent - состояние когда объект уже хранится в БД либо будет сохранен по окончании транзакции (был вызван метод persist)
Removed - удаленное состояние. Объект который будет удален из БД (вызов метода remove) после завершения транзакции.
    После коммита транзакции сущность переходит в состояние Transient
Detached - состояние объекта существующего в бд после закрытия Persistent Context

PersistentContext имеет область гарантированной идентичности объектов. В контексте одну строку БД представляет лишь один экземпляр объекта:
    т.е работает и == и equals

Синхронизация контекста:
    при вызове flush()
    перед коммитом транзакции
    перед выполнением JPQL/HQL-запроса (FlushMode)
    при вызове find(), merge(), refresh()


Транзации
    Уровень изоляции
        READ UNCOMMITTED(Dirty Read, Non‑repeatable Read, Phantom Read)
        READ COMMITTED(Non‑repeatable Read, Phantom Read)
        REPEATABLE READ(Phantom Read)
        SERIALIZABLE

        Проблемы
            грязное чтение(Dirty Read) чтение незакоммиченных данных который могут откатиться
            неповторяющееся чтение(Non‑repeatable Read) - после чтения данных и до завершения транзации кто-то может изменить эти данные
            фантомное чтение(Phantom Read) - добавление или удаленние строк в таблицу

    Propagation(распространение)
        Propagation.REQUIRED — выполняться в существующей транзакции, если она есть, иначе создавать новую.
        Propagation.MANDATORY — выполняться в существующей транзакции, если она есть, иначе генерировать исключение.
        Propagation.SUPPORTS — выполняться в существующей транзакции, если она есть, иначе выполняться вне транзакции.
        Propagation.NOT_SUPPORTED — всегда выполняться вне транзакции. Если есть существующая, то она будет остановлена.
        Propagation.REQUIRES_NEW — всегда выполняться в новой независимой транзакции. Если есть существующая, то она будет остановлена до окончания выполнения новой транзакции.
        Propagation.NESTED — если есть текущая транзакция, выполняться в новой, так называемой, вложенной транзакции. Если вложенная транзакция будет отменена, то это не повлияет на внешнюю транзакцию; если будет отменена внешняя транзакция, то будет отменена и вложенная. Если текущей транзакции нет, то просто создаётся новая.
        Propagation.NEVER — всегда выполнять вне транзакции, при наличии существующей генерировать исключение.
